Creating an Android app that posts tweets from a file at random times involves several steps. We'll focus on a simplified version to demonstrate the concept. This app will:

1. Read tweets from a local file.
2. Post tweets to Twitter.
3. Schedule tweets at random times.

Hereâ€™s a step-by-step guide:

### Dependencies
Add the necessary dependencies to your `build.gradle` file:

```gradle
implementation 'com.squareup.okhttp3:okhttp:4.9.1'
implementation 'com.twitter.sdk.android:twitter-core:3.3.0'
implementation 'com.twitter.sdk.android:twitter:3.3.0'
implementation 'androidx.work:work-runtime-ktx:2.7.1'
```

### MainActivity.kt
Create a `MainActivity.kt` file:

```kotlin
package com.example.scheduledtweets

import android.os.Bundle
import android.widget.Button
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.work.*
import com.twitter.sdk.android.core.*
import com.twitter.sdk.android.core.identity.TwitterAuthClient
import com.twitter.sdk.android.tweetcomposer.TweetComposer
import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.concurrent.TimeUnit
import kotlin.random.Random

class MainActivity : AppCompatActivity() {

    private lateinit var twitterAuthClient: TwitterAuthClient

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Twitter.initialize(this)
        setContentView(R.layout.activity_main)

        twitterAuthClient = TwitterAuthClient()

        val postButton: Button = findViewById(R.id.postButton)
        postButton.setOnClickListener {
            authenticateAndScheduleTweets()
        }
    }

    private fun authenticateAndScheduleTweets() {
        val session = TwitterCore.getInstance().sessionManager.activeSession
        if (session == null) {
            twitterAuthClient.authorize(this, object : Callback<TwitterSession>() {
                override fun success(result: Result<TwitterSession>?) {
                    scheduleTweets()
                }

                override fun failure(exception: TwitterException?) {
                    Toast.makeText(this@MainActivity, "Twitter authentication failed", Toast.LENGTH_SHORT).show()
                }
            })
        } else {
            scheduleTweets()
        }
    }

    private fun scheduleTweets() {
        val tweets = readTweetsFromFile()
        for (tweet in tweets) {
            val delay = Random.nextLong(1, 60) // Random delay between 1 to 60 minutes
            val tweetWorkRequest = OneTimeWorkRequestBuilder<TweetWorker>()
                .setInitialDelay(delay, TimeUnit.MINUTES)
                .setInputData(workDataOf("tweet" to tweet))
                .build()
            WorkManager.getInstance(this).enqueue(tweetWorkRequest)
        }
        Toast.makeText(this, "Tweets scheduled", Toast.LENGTH_SHORT).show()
    }

    private fun readTweetsFromFile(): List<String> {
        val tweets = mutableListOf<String>()
        val inputStream = assets.open("tweets.txt")
        BufferedReader(InputStreamReader(inputStream)).use { reader ->
            var line = reader.readLine()
            while (line != null) {
                tweets.add(line)
                line = reader.readLine()
            }
        }
        return tweets
    }
}
```

### TweetWorker.kt
Create a `TweetWorker.kt` file to handle the actual posting of tweets:

```kotlin
package com.example.scheduledtweets

import android.content.Context
import androidx.work.Worker
import androidx.work.WorkerParameters
import com.twitter.sdk.android.core.TwitterCore
import com.twitter.sdk.android.core.models.Tweet
import com.twitter.sdk.android.tweetcomposer.TweetComposer
import java.lang.Exception

class TweetWorker(appContext: Context, workerParams: WorkerParameters) : Worker(appContext, workerParams) {

    override fun doWork(): Result {
        val tweetText = inputData.getString("tweet") ?: return Result.failure()
        return try {
            postTweet(tweetText)
            Result.success()
        } catch (e: Exception) {
            Result.retry()
        }
    }

    private fun postTweet(tweetText: String) {
        val session = TwitterCore.getInstance().sessionManager.activeSession
        val intent = TweetComposer.Builder(applicationContext)
            .session(session)
            .text(tweetText)
            .createIntent()
        intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
        applicationContext.startActivity(intent)
    }
}
```

### activity_main.xml
Create a simple layout file `activity_main.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <Button
        android:id="@+id/postButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Schedule Tweets"
        android:layout_centerInParent="true" />
</RelativeLayout>
```

### Notes
1. **Twitter API**: Ensure you have registered your app with Twitter and obtained the necessary API keys. Configure the app in the Twitter developer portal.
2. **File Handling**: Place the `tweets.txt` file in the `assets` folder of your Android project.
3. **Permissions**: Handle the necessary permissions and authentication flows for both network access and Twitter API access.
4. **Error Handling**: Add proper error handling and user feedback mechanisms.

This example provides a basic framework to build upon. For a production app, consider additional features like improved error handling, more flexible scheduling, and better user interaction.