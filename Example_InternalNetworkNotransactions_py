To move crypto coins through an internal system without transactions using a NodeMCU, you can create a simple IoT-based internal ledger system. This involves setting up a server (which could be an external server or a local server like a Raspberry Pi) to manage the ledger and using the NodeMCU to interact with this server over Wi-Fi.

### Components Required:
1. **NodeMCU**: For handling interactions and sending requests.
2. **Server**: To maintain the internal ledger (can be a PC, Raspberry Pi, or any other server).
3. **Wi-Fi**: For NodeMCU to communicate with the server.

### Steps to Implement:

1. **Set Up the Server**: Create an API to handle user balance management.
2. **NodeMCU Code**: Write code for the NodeMCU to interact with the server.

#### 1. Set Up the Server

We'll use Flask (a lightweight Python web framework) to create the server.

**Install Flask**:
```bash
pip install flask
```

**Server Code (server.py)**:
```python
from flask import Flask, request, jsonify
import sqlite3

app = Flask(__name__)
db_path = 'internal_ledger.db'

def init_db():
    conn = sqlite3.connect(db_path)
    c = conn.cursor()
    c.execute('''
    CREATE TABLE IF NOT EXISTS balances (
        user_id TEXT PRIMARY KEY,
        balance REAL NOT NULL
    )
    ''')
    conn.commit()
    conn.close()

@app.route('/add_user', methods=['POST'])
def add_user():
    user_id = request.json['user_id']
    initial_balance = request.json.get('initial_balance', 0.0)
    conn = sqlite3.connect(db_path)
    c = conn.cursor()
    c.execute('INSERT INTO balances (user_id, balance) VALUES (?, ?)', (user_id, initial_balance))
    conn.commit()
    conn.close()
    return jsonify({"message": "User added"}), 201

@app.route('/get_balance/<user_id>', methods=['GET'])
def get_balance(user_id):
    conn = sqlite3.connect(db_path)
    c = conn.cursor()
    c.execute('SELECT balance FROM balances WHERE user_id = ?', (user_id,))
    result = c.fetchone()
    conn.close()
    if result:
        return jsonify({"balance": result[0]})
    else:
        return jsonify({"message": "User not found"}), 404

@app.route('/transfer', methods=['POST'])
def transfer():
    from_user = request.json['from_user']
    to_user = request.json['to_user']
    amount = request.json['amount']
    
    conn = sqlite3.connect(db_path)
    c = conn.cursor()
    
    c.execute('SELECT balance FROM balances WHERE user_id = ?', (from_user,))
    from_balance = c.fetchone()
    
    c.execute('SELECT balance FROM balances WHERE user_id = ?', (to_user,))
    to_balance = c.fetchone()
    
    if not from_balance or not to_balance:
        return jsonify({"message": "One or both users do not exist"}), 404
    
    if from_balance[0] < amount:
        return jsonify({"message": "Insufficient balance"}), 400
    
    c.execute('UPDATE balances SET balance = ? WHERE user_id = ?', (from_balance[0] - amount, from_user))
    c.execute('UPDATE balances SET balance = ? WHERE user_id = ?', (to_balance[0] + amount, to_user))
    
    conn.commit()
    conn.close()
    return jsonify({"message": "Transfer successful"})

if __name__ == '__main__':
    init_db()
    app.run(host='0.0.0.0', port=5000)
```

#### 2. NodeMCU Code

**NodeMCU Code (main.ino)**:
```cpp
#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include <ArduinoJson.h>

const char* ssid = "Your_SSID";
const char* password = "Your_PASSWORD";
const char* serverUrl = "http://<YOUR_SERVER_IP>:5000";

void setup() {
  Serial.begin(115200);
  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi...");
  }
  Serial.println("Connected to WiFi");

  // Add a user
  addUser("user1", 100.0);
  addUser("user2", 50.0);

  // Get balance
  Serial.println("User1 Balance: " + getBalance("user1"));
  Serial.println("User2 Balance: " + getBalance("user2"));

  // Transfer balance
  transferBalance("user1", "user2", 25.0);

  // Get updated balances
  Serial.println("User1 Balance: " + getBalance("user1"));
  Serial.println("User2 Balance: " + getBalance("user2"));
}

void loop() {
  // Your main code
}

void addUser(String userId, float initialBalance) {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    http.begin(serverUrl + "/add_user");
    http.addHeader("Content-Type", "application/json");

    StaticJsonDocument<200> jsonDoc;
    jsonDoc["user_id"] = userId;
    jsonDoc["initial_balance"] = initialBalance;
    String requestBody;
    serializeJson(jsonDoc, requestBody);

    int httpResponseCode = http.POST(requestBody);
    if (httpResponseCode > 0) {
      String response = http.getString();
      Serial.println(response);
    } else {
      Serial.println("Error on sending POST: " + String(httpResponseCode));
    }
    http.end();
  }
}

String getBalance(String userId) {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    http.begin(serverUrl + "/get_balance/" + userId);

    int httpResponseCode = http.GET();
    if (httpResponseCode > 0) {
      String response = http.getString();
      StaticJsonDocument<200> jsonDoc;
      deserializeJson(jsonDoc, response);
      float balance = jsonDoc["balance"];
      http.end();
      return String(balance);
    } else {
      Serial.println("Error on sending GET: " + String(httpResponseCode));
      http.end();
      return "";
    }
  }
  return "";
}

void transferBalance(String fromUser, String toUser, float amount) {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    http.begin(serverUrl + "/transfer");
    http.addHeader("Content-Type", "application/json");

    StaticJsonDocument<200> jsonDoc;
    jsonDoc["from_user"] = fromUser;
    jsonDoc["to_user"] = toUser;
    jsonDoc["amount"] = amount;
    String requestBody;
    serializeJson(jsonDoc, requestBody);

    int httpResponseCode = http.POST(requestBody);
    if (httpResponseCode > 0)